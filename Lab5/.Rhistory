install.packages("WGCNA", dependencies=T)
source("http://bioconductor.org/biocLite.R")
biocLite(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
biocLite("WGCNA")
install.package("WGCNA")
install.packages("WGCNA")
require("WGCNA")
install.packages("WGCNA")
update.packages()
update.packages()
require("WGCNA")
install.packages("WGCNA")
install.packages("WGCNA", dependencies = T)
install.packages("impute")
package_version(R)
package_version("R")
package_version("WGCNA")
install.packages("GO.db")
source("http://bioconductor.org/biocLite.R")
biocLite(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
biocLite("WGCNA")
source("http://bioconductor.org/biocLite.R")
biocLite(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
biocLite("WGCNA")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
BiocManager::install(version = "3.11")
install.packages("foreign")
install.packages("mgcv")
BiocManager::install(version = "3.11")
install.packages("nlme")
install.packages("spatial")
install.packages("survival")
BiocManager::install(version = "3.11")
BiocManager::install(version = "3.11")
source("http://bioconductor.org/biocLite.R")
if (!requireNamespace("BiocManager", quietly = TRUE))
BiocManager::install(version = "3.11")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
package_version("foreign")
require("foreign")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
library(foreign)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
update.packages(foreign)
update.packages("foreign")
update.packages("mgcv")
update.packages("nlme")
update.packages("spatial")
update.packages("survival")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
library(devtools)
install_github("insilico/npdr")
library(npdr)
SxG.dat <- t(GxS.covfilter)
npdr.MDD.results <- npdr(pheno.factor, SxG.dat,
regression.type="binomial",
attr.diff.type="numeric-abs",
nbd.method="multisurf",
nbd.metric = "manhattan",
msurf.sd.frac=.5, k=0,
neighbor.sampling="none",
dopar.nn = F, dopar.reg = T,
padj.method="bonferroni", verbose=F)
colnames(npdr.MDD.results)
library(dplyr)
# attributes with FDR-adjusted p-value<.05
top.p05.npdr <- npdr.MDD.results %>% filter(pval.adj<.05) %>% pull(att)
SxG.dat <- t(GxS.covfilter)
npdr.MDD.results <- npdr(pheno.factor, SxG.dat,
regression.type="binomial",
attr.diff.type="numeric-abs",
nbd.method="multisurf",
nbd.metric = "manhattan",
msurf.sd.frac=.5, k=0,
neighbor.sampling="none",
dopar.nn = F, dopar.reg = F,
padj.method="bonferroni", verbose=F)
colnames(npdr.MDD.results)
SxG.dat <- t(GxS.covfilter)
npdr.MDD.results <- npdr(pheno.factor, SxG.dat,
regression.type="binomial",
attr.diff.type="numeric-abs",
nbd.method="multisurf",
nbd.metric = "manhattan",
msurf.sd.frac=.5, k=0,
neighbor.sampling="none",
dopar.nn = F, dopar.reg = F,
padj.method="bonferroni", verbose=F)
setwd("/home/swpshadow/Documents/Bio/Lab5")
# load gene expression data
####################LAB SETUP#########################
load("sense.filtered.cpm.Rdata")  # setwd!
# load phenotype (mdd/hc) data
subject.attrs <- read.csv("Demographic_symptom.csv",
stringsAsFactors = FALSE)
library(dplyr)
# grab intersecting X (subject ids) and Diag (Diagnosis) from columns
phenos.df <- subject.attrs %>%
filter(X %in% colnames(sense.filtered.cpm)) %>%
dplyr::select(X, Diag)
mddPheno <- as.factor(phenos.df$Diag)
# Normalized and transform
library(preprocessCore)
mddExprData_quantile <- normalize.quantiles(sense.filtered.cpm)
mddExprData_quantileLog2 <- log2(mddExprData_quantile)
# attach phenotype names and gene names to data
colnames(mddExprData_quantileLog2) <- mddPheno
rownames(mddExprData_quantileLog2) <- rownames(sense.filtered.cpm)
# coefficient of variation filter sd(x)/abs(mean(x))
CoV_values <- apply(mddExprData_quantileLog2,1,
function(x) {sd(x)/abs(mean(x))})
# smaller threshold, the higher the experimental effect relative to the
# measurement precision
sum(CoV_values<.045)
# there is one gene that has 0 variation -- remove
sd_values <- apply(mddExprData_quantileLog2,1, function(x) {sd(x)})
rownames(mddExprData_quantileLog2)[sd_values==0]
# filter the data matrix
GxS.covfilter <- mddExprData_quantileLog2[CoV_values<.045 & sd_values>0,]
dim(GxS.covfilter)
# convert phenotype to factor
pheno.factor <- as.factor(colnames(GxS.covfilter))
pheno.factor
str(pheno.factor)
levels(pheno.factor)
####################START OF LAB#########################
##### A #####
# make sure HC is the reference level
pheno.factor.relevel <- relevel(pheno.factor,"HC")
levels(pheno.factor.relevel)
# also rename levels "0"/"1" from 1/2
levels(pheno.factor.relevel)[levels(pheno.factor.relevel)=="MDD"] <- 1
levels(pheno.factor.relevel)[levels(pheno.factor.relevel)=="HC"] <- 0
gene.row <- 2
gene.name <-rownames(GxS.covfilter)[gene.row]
gene.expr <- GxS.covfilter[gene.row,]
gene.fit <- glm(pheno.factor.relevel~gene.expr, family=binomial)
summary(gene.fit)
coeff.mat <- coef(summary(gene.fit))
b0 <- coeff.mat[1,1]
b1 <- coeff.mat[2,1]
b1.pval <- coeff.mat[2,4]
modelfn <- function(x){1/(1+exp(-(b0+b1*x)))}
g.min <- min(gene.expr)
g.max <- max(gene.expr)
curve(modelfn,g.min,g.max)  # plot for domain of actual geneâ€™s expression
abline(h=.5, lty=2)
curve(modelfn,3,8)     # replot with extended domain to see the S shape
abline(h=.5, lty=2)
predicted.probs <- predict(gene.fit, gene.expr=gene.expr,
type="response")
library(ggplot2)
phenotype <- pheno.factor # just rename for legend
gene.gg.df <- data.frame(expression=gene.expr,
prediction=predicted.probs)
# plot predicted probabilities versus gene expression
p <- ggplot(data=gene.gg.df)
p <- p + geom_point(aes(x=expression,
y=prediction,
color=phenotype,  # shape and color
shape=phenotype), # are true phenotype
size=3)
p <- p + geom_hline(yintercept = .5, linetype="dashed", color="red")
print(p)
##### B #####
# vector of logistic output probabilities for this model (glm/eq. above)
# prob = .5 is the threshold for prediction class = 1 vs 0
predicted.class <- as.integer(predicted.probs >=.5)  # predicted class
pheno.factor.relevel  # true class
# vector of True (correctly predicted) and False (wrongly predicted)
correct.class <- predicted.class == pheno.factor.relevel
print(sum(predicted.class==1))
#### ACCURACY CODE ###
print(sum(correct.class==TRUE)/length(correct.class))
##### C #####
# logistic regression function for one gene row
lr.fn <- function(i){
gene=rownames(GxS.covfilter)[i]
gene.expr <- GxS.covfilter[i,]
gene.fit <- glm(pheno.factor.relevel~gene.expr,
family=binomial)
coeff.mat <- coef(summary(gene.fit))
b1 <- coeff.mat[2,1]
b1.pval <- coeff.mat[2,4]
coefvec <- gene.fit$estimate # intercept, gene
pvec <- gene.fit$p.value     # intercept, gene
c(gene, b1, b1.pval)
}
lr.fn(2)
# initialize results matrix
num.genes<-nrow(GxS.covfilter)
lr.results.mat <- matrix(0, nrow=nrow(GxS.covfilter), ncol=3)
# for loop the function to all genes
for (i in 1:num.genes){
lr.results.mat[i,] <- lr.fn(i)
}
lr.results.df <- data.frame(lr.results.mat)
colnames(lr.results.df) <- c("gene", "b1", "p.val")
# sort results b1 coefficient p-value
library(dplyr)
lr.results.sorted <- lr.results.df %>%
mutate_at("p.val", as.character) %>%
mutate_at("p.val", as.numeric) %>%
arrange(p.val)
lr.results.sorted[1:10,]
print(lr.results.sorted[1:10,])
gene.row <- which(rownames(GxS.covfilter)=="MDGA1")
gene.expr <- GxS.covfilter[gene.row,]
gene.fit <- glm(pheno.factor.relevel~gene.expr,
family=binomial)
predicted.probs <- predict(gene.fit, gene.expr=gene.expr, type="response")
# Add Plotting Code
phenotype <- pheno.factor # just rename for legend
gene.gg.df <- data.frame(expression=gene.expr,
prediction=predicted.probs)
# plot predicted probabilities versus gene expression
p <- ggplot(data=gene.gg.df)
p <- p + geom_point(aes(x=expression,
y=prediction,
color=phenotype,  # shape and color
shape=phenotype), # are true phenotype
size=3)
p <- p + geom_hline(yintercept = .5, linetype="dashed", color="red")
print(p)
# Add code for accuracy
predicted.class <- as.integer(predicted.probs >=.5)  # predicted class
pheno.factor.relevel  # true class
# vector of True (correctly predicted) and False (wrongly predicted)
correct.class <- predicted.class == pheno.factor.relevel
print(sum(predicted.class==1))
print(sum(correct.class==TRUE))
#### ACCURACY CODE ###
print(sum(correct.class==TRUE)/length(correct.class))
##### D #####
library(glmnet) # install.packages("glmnet")
# alpha=0 means ridge, alpha=1 means lasso
glmnet.model <- cv.glmnet(t(GxS.covfilter), pheno.factor.relevel, alpha=.1,
family="binomial", type.measure="class")
plot(glmnet.model) # plot of CV error vs lambda penalty
glmnet.model$lambda.min # lambda that minimizes the CV error
# get the penalized regression coefficients
glmnet.coeffs <- predict(glmnet.model,type="coefficients")
# get the coefficients that are not zero (these are the selected variables)
glmnet.nonzero.coeffs <- glmnet.coeffs@Dimnames[[1]][which(glmnet.coeffs!=0)]
glmnet.nonzero.coeffs
# apply the glmnet model to the data to get class predictions
glmnet.predicted <- predict(glmnet.model,
s=glmnet.model$lambda.min, # lambda to use
type="class",              # classify
newx=t(GxS.covfilter))     # apply to original
glmnet.accuracy <- mean(factor(glmnet.predicted)==pheno.factor.relevel)
glmnet.accuracy
##### E #####
#install.packages("devtools")
library(devtools)
#install_github("insilico/npdr")
library(npdr)
#https://github.com/insilico/npdr
SxG.dat <- t(GxS.covfilter)
npdr.MDD.results <- npdr(pheno.factor, SxG.dat,
regression.type="binomial",
attr.diff.type="numeric-abs",
nbd.method="multisurf",
nbd.metric = "manhattan",
msurf.sd.frac=.5, k=0,
neighbor.sampling="none",
dopar.nn = F, dopar.reg = F,
padj.method="bonferroni", verbose=F)
colnames(npdr.MDD.results)
library(dplyr)
# attributes with FDR-adjusted p-value<.05
top.p05.npdr <- npdr.MDD.results %>% filter(pval.adj<.05) %>% pull(att)
### 10 ###
# grab top 200, remove NA, remove "", get att col
top.npdr <- npdr.MDD.results %>% dplyr::slice(1:200) %>%
drop_na(att) %>% filter(att!="") %>% pull(att)
write.table(top.npdr,row.names=F,col.names=F,quote=F)
SxG.dat <- t(GxS.covfilter)
npdr.MDD.results <- npdr(pheno.factor, SxG.dat,
regression.type="binomial",
attr.diff.type="numeric-abs",
nbd.method="multisurf",
nbd.metric = "manhattan",
msurf.sd.frac=.5, k=0,
neighbor.sampling="none",
dopar.nn = F, dopar.reg = F,
padj.method="bonferroni", verbose=F)
colnames(npdr.MDD.results)
# attributes with FDR-adjusted p-value<.05
top.p05.npdr <- npdr.MDD.results %>% filter(pval.adj<.05) %>% pull(att)
print(top.p05.npdr)
top.npdr <- npdr.MDD.results %>% dplyr::slice(1:200) %>%
drop_na(att) %>% filter(att!="") %>% pull(att)
write.table(top.npdr,row.names=F,col.names=F,quote=F)
top.1.npdr <- npdr.MDD.results %>% filter(pval.adj<1) %>% pull(att)
top.npdr <- top.1.npdr %>% dplyr::slice(1:200) %>%
drop_na(att) %>% filter(att!="") %>% pull(att)
write.table(top.npdr,row.names=F,col.names=F,quote=F)
